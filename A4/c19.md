### C19 - Tester la partie back-end de l’application à plusieurs niveaux en utilisant des méthodes de test standards afin de garantir sa conformité vis-à-vis des spécifications et assurer la non-régression des composants implémentés

#### C19.1 - Élaborer un plan de tests logiciels exhaustif pour le back-end

Pour élaborer un plan de tests exhaustif pour le back-end, il est nécessaire de définir une stratégie claire couvrant les différents types de tests à réaliser, tels que les tests unitaires, les tests d'intégration et les tests fonctionnels. Le plan doit inclure les objectifs de chaque test, les outils à utiliser, les critères d'acceptation, et un calendrier précis. Les cas de test doivent être détaillés avec des scénarios spécifiques, les données d'entrée, les étapes à suivre et les résultats attendus.

#### C19.2 - Réaliser des tests unitaires sur les composants du back-end

Les tests unitaires sont essentiels pour vérifier que chaque composant individuel du back-end fonctionne correctement. En utilisant des frameworks de test comme Jest ou Mocha, chaque fonction ou méthode est testée de manière isolée pour s'assurer qu'elle produit les résultats attendus. Les tests doivent couvrir toutes les conditions possibles, y compris les cas limites et les erreurs potentielles.

##### Exemple de test unitaire

Voici un exemple simple de test unitaire en utilisant Jest pour une fonction de calcul de la somme, écrit en TypeScript :

```typescript
// sum.ts
export function sum(a: number, b: number): number {
  return a + b;
}

// sum.test.ts
import { sum } from "./sum";

test("adds 1 + 2 to equal 3", () => {
  expect(sum(1, 2)).toBe(3);
});

test("adds -1 + 1 to equal 0", () => {
  expect(sum(-1, 1)).toBe(0);
});
```

#### C19.3 - Réaliser des tests fonctionnels sur les composants du back-end

Les tests fonctionnels visent à vérifier que les composants du back-end fonctionnent comme prévu dans des scénarios d'utilisation réels. Cela inclut la validation des flux de travail, la gestion des erreurs et l'interaction avec d'autres services ou bases de données. Les tests sont généralement automatisés à l'aide d'outils comme Postman ou Cypress, et les résultats sont comparés aux spécifications initiales pour assurer la conformité.

##### Exemple de test fonctionnel

Voici un exemple de test fonctionnel en utilisant Jest et Supertest pour tester une API de création d'utilisateur en TypeScript :

```typescript
// userController.ts
import { Request, Response } from "express";
import { User } from "./userModel";

export const createUser = async (
  req: Request,
  res: Response
): Promise<void> => {
  const { name, email, password } = req.body;
  const newUser = new User({ name, email, password });
  await newUser.save();
  res.status(201).json(newUser);
};

// user.test.ts
import request from "supertest";
import app from "./app"; // L'application Express

describe("Test API création utilisateur", () => {
  it("devrait créer un nouvel utilisateur", async () => {
    const response = await request(app).post("/api/users").send({
      name: "John Doe",
      email: "john.doe@example.com",
      password: "password123",
    });
    expect(response.status).toBe(201);
    expect(response.body.name).toBe("John Doe");
    expect(response.body.email).toBe("john.doe@example.com");
  });
});
```
