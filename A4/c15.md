### C15 - Développer la couche de persistance des données en appliquant les bonnes pratiques de sécurité informatique et de performance

#### C15.1 - Mettre en œuvre et administrer des bases de données relationnelles de manière sécurisée
J'ai mis en œuvre et administré des bases de données relationnelles en accordant une attention particulière à la sécurité et à la performance. En utilisant TypeORM, j'ai configuré des connexions sécurisées avec SSL/TLS et défini des politiques de gestion des utilisateurs et des rôles pour contrôler l'accès aux données.

#### C15.2 - Exploiter et interroger des bases de données relationnelles depuis le backend de l’application
J'ai exploité et interrogé des bases de données relationnelles depuis le backend de l'application en utilisant TypeORM. Cette bibliothèque facilite l'exécution de requêtes SQL, la création et la gestion des entités et des relations, ainsi que l'optimisation des performances des requêtes grâce à l'utilisation des index et des vues.

```typescript
export const AppDataSource = new DataSource({
    type: process.env.DB_TYPE as any,
    host: process.env.DB_HOST,
    port: parseInt(process.env.DB_PORT as string, 10),
    username: process.env.DB_USERNAME,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_DATABASE,
    synchronize: true,
    logging: true,
    entities: [User],
    subscribers: [],
    migrations: [],
});
```

```typescript
import { createConnection, getRepository } from "typeorm";
import { User } from "./entity/User";

async function createDatabaseConnection() {
  try {
    const connection = await createConnection();

    const userRepository = getRepository(User);

    const newUser = new User();
    newUser.firstName = "John";
    newUser.lastName = "Doe";
    newUser.age = 25;
    await userRepository.save(newUser);

    const user = await userRepository.findOne({ firstName: "John" });

    if (user) {
      user.lastName = "Smith";
      await userRepository.save(user);
    }

    if (user) {
      await userRepository.remove(user);
    }
  }
  catch (error) {
    console.error("Error: ", error);
    await connection.close();
  }
}

createConnection();
```

#### C15.3 - Mettre en œuvre et administrer des bases de données NoSQL de manière sécurisée
J'ai mis en œuvre et administré des bases de données NoSQL de manière sécurisée, en utilisant TypeORM pour travailler avec des bases de données telles que MongoDB. Cela a impliqué l'utilisation de mécanismes d'authentification robustes, la configuration des permissions d'accès et l'application de politiques de chiffrement des données.

#### C15.4 - Exploiter et interroger des bases de données NoSQL
J'ai exploité et interrogé des bases de données NoSQL, notamment en utilisant Mongoose pour des applications Node.js. Cette bibliothèque m'a permis de définir des schémas, d'exécuter des requêtes et de manipuler des données efficacement.

```typescript
import mongoose from 'mongoose';

mongoose.connect('mongodb://localhost:27017/database', { useNewUrlParser: true, useUnifiedTopology: true });

const db = mongoose.connection;
db.on('error', console.error.bind(console, 'connection error:'));
db.once('open', function() {
  
  const userSchema = new mongoose.Schema({
    firstName: String,
    lastName: String,
    age: Number
  });

  const User = mongoose.model('User', userSchema);

  const newUser = new User({ firstName: 'Jane', lastName: 'Doe', age: 28 });
  newUser.save(function (err, user) {
    if (err) return console.error(err);

    User.findOne({ firstName: 'Jane' }, function (err, user) {
      if (err) return console.error(err);

      user.lastName = 'Smith';
      user.save(function (err, updatedUser) {
        if (err) return console.error(err);

        User.deleteOne({ _id: updatedUser._id }, function (err) {
          if (err) return console.error(err);
          
          mongoose.connection.close();
        });
      });
    });
  });
});
```

#### C15.5 - Faire évoluer les bases de données
J'ai assuré l'évolution des bases de données en utilisant les outils intégrés de TypeORM pour générer, exécuter et gérer les migrations de schéma, garantissant ainsi la continuité et la stabilité des applications sans interruption du service.
