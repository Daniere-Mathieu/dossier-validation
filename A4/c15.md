### Compétence C15 : Développer la couche de persistance des données en appliquant les bonnes pratiques de sécurité informatique et de performance

#### C15.1 - Mettre en œuvre et administrer des bases de données relationnelles de manière sécurisée
Pour cette sous-compétence, il est essentiel de :
- **Choisir un SGBD (Système de Gestion de Base de Données)** adapté aux besoins de l'application.
- **Configurer les bases de données** en respectant les normes de sécurité, telles que l'utilisation de connexions chiffrées (SSL/TLS).
- **Gérer les droits d'accès** de manière granulaire pour garantir que chaque utilisateur ou application dispose uniquement des permissions nécessaires.
- **Mettre en place des mécanismes de sauvegarde et de restauration** pour garantir la continuité de service et la récupération des données en cas d'incident.

#### C15.2 - Exploiter et interroger des bases de données relationnelles depuis le backend de l’application
Pour cette sous-compétence, il est nécessaire de :
- **Établir des connexions sécurisées** avec la base de données à partir du backend.
- **Rédiger des requêtes SQL** optimisées pour l'exploitation des données tout en minimisant l'impact sur les performances.
- **Utiliser des ORM (Object-Relational Mapping)** pour simplifier l'interaction avec la base de données tout en maintenant un niveau de sécurité élevé.

##### Exemple avec TypeORM et NestJS :

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        type: 'postgres',
        host: configService.get('DATABASE_HOST'),
        port: configService.get('DATABASE_PORT'),
        username: configService.get('DATABASE_USERNAME'),
        password: configService.get('DATABASE_PASSWORD'),
        database: configService.get('DATABASE_NAME'),
        entities: [__dirname + '/../**/*.entity{.ts,.js}'],
        synchronize: true,
        ssl: {
          rejectUnauthorized: false,
        },
      }),
      inject: [ConfigService],
    }),
  ],
})
export class AppModule {}
```

```typescript
// user.entity.ts
import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ length: 50 })
  firstName: string;

  @Column({ length: 50 })
  lastName: string;

  @Column({ unique: true })
  email: string;

  @Column()
  password: string;
}
```

```typescript
// user.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './user.entity';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private usersRepository: Repository<User>,
  ) {}

  async createUser(firstName: string, lastName: string, email: string, password: string): Promise<User> {
    const newUser = this.usersRepository.create({ firstName, lastName, email, password });
    return this.usersRepository.save(newUser);
  }

  async findUserByEmail(email: string): Promise<User> {
    return this.usersRepository.findOne({ where: { email } });
  }
}
```

#### C15.3 - Mettre en œuvre et administrer des bases de données NoSQL de manière sécurisée
Pour cette sous-compétence, il est essentiel de :
- **Choisir une solution NoSQL** adaptée aux besoins de l'application (e.g., MongoDB, Cassandra, Redis).
- **Configurer les bases de données NoSQL** en respectant les bonnes pratiques de sécurité, y compris le chiffrement des données au repos et en transit.
- **Gérer les accès et les permissions** de manière appropriée pour garantir la sécurité des données.

#### C15.4 - Exploiter et interroger des bases de données NoSQL
Pour cette sous-compétence, il est nécessaire de :
- **Établir des connexions sécurisées** avec la base de données NoSQL.
- **Rédiger des requêtes adaptées** au type de base de données NoSQL utilisée, en tenant compte des spécificités de chaque système (e.g., requêtes MongoDB, CQL pour Cassandra).
- **Optimiser les requêtes** pour garantir des performances élevées, même avec de grandes volumétries de données.

##### Exemple avec Mongoose et NestJS :

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        uri: configService.get('MONGODB_URI'),
        useNewUrlParser: true,
        useUnifiedTopology: true,
      }),
      inject: [ConfigService],
    }),
  ],
})
export class AppModule {}
```

```typescript
// user.schema.ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type UserDocument = User & Document;

@Schema()
export class User {
  @Prop({ required: true })
  firstName: string;

  @Prop({ required: true })
  lastName: string;

  @Prop({ unique: true, required: true })
  email: string;

  @Prop({ required: true })
  password: string;
}

export const UserSchema = SchemaFactory.createForClass(User);
```

```typescript
// user.service.ts
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User, UserDocument } from './user.schema';

@Injectable()
export class UserService {
  constructor(
    @InjectModel(User.name) private userModel: Model<UserDocument>,
  ) {}

  async createUser(firstName: string, lastName: string, email: string, password: string): Promise<User> {
    const newUser = new this.userModel({ firstName, lastName, email, password });
    return newUser.save();
  }

  async findUserByEmail(email: string): Promise<User> {
    return this.userModel.findOne({ email }).exec();
  }
}
```

#### C15.5 - Faire évoluer les bases de données
Pour cette sous-compétence, il est crucial de :
- **Planifier les évolutions** des schémas de base de données en fonction des besoins changeants de l'application.
- **Utiliser des outils de migration** de schémas pour appliquer les modifications de manière contrôlée et sans interruption de service.
- **Assurer la compatibilité ascendante** pour permettre aux anciennes versions de l'application de continuer à fonctionner avec les nouvelles versions des schémas de données.

Ces pratiques visent à assurer une gestion sécurisée, efficace et évolutive des données, élément crucial pour la performance globale de l'application et la protection des informations sensibles.
