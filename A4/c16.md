### C16 - Développer la partie back-end d’une application en utilisant plusieurs langages de programmation et en appliquant les bonnes pratiques de sécurité informatique et d’écoconception

#### C16.1 - Sélectionner et mettre en œuvre un ou plusieurs langages de programmation back-end adaptés aux exigences et contraintes de l’application ou du site web
J'ai sélectionné et mis en œuvre des langages de programmation back-end tels que TypeScript pour ses avantages en termes de typage statique et de maintenabilité du code. TypeScript permet de détecter les erreurs à la compilation et améliore la lisibilité du code, ce qui est essentiel pour des projets à grande échelle.

#### C16.2 - Sélectionner et mettre en œuvre un framework de développement backend adaptés aux exigences et contraintes de l’application ou du site web
J'ai mis en œuvre des frameworks de développement backend comme NestJS, qui est basé sur TypeScript. NestJS offre une architecture modulaire et orientée service, ce qui facilite la création d'applications évolutives et maintenables. Voici un exemple de configuration de serveur avec NestJS :

```typescript
import { Module } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

@Module({
  imports: [],
  controllers: [],
  providers: [],
})
class AppModule {}

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log('Server running on http://localhost:3000');
}
bootstrap();
```

#### C16.3 - À partir du référentiel de modélisation, développer des composants back-end fonctionnels en choisissant des structures de données adaptées et des algorithmes pertinents afin d’assurer la qualité logicielle
En utilisant le référentiel de modélisation, j'ai développé des composants back-end en choisissant des structures de données et des algorithmes adaptés pour optimiser les performances et la qualité logicielle. Par exemple, j'ai utilisé des structures de données comme les arbres AVL pour maintenir un équilibre et améliorer les temps de recherche.

#### C16.4 - Appliquer les recommandations de sécurité pour le développement backend afin de s’inscrire dans une démarche de « sécurité en profondeur »
J'ai appliqué les recommandations de sécurité pour le développement back-end afin de renforcer la protection des données et des systèmes. Cela inclut l'utilisation de mécanismes d'authentification et d'autorisation robustes, le chiffrement des données sensibles, et la validation des entrées utilisateur pour prévenir les injections SQL et les attaques XSS.

```typescript
import { Controller, Post, Body, Get, Param } from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './create-user.dto';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  async create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Get(':id')
  async findOne(@Param('id') id: string) {
    return this.usersService.findOne(id);
  }
}

import { Injectable } from '@nestjs/common';
import { CreateUserDto } from './create-user.dto';

@Injectable()
export class UsersService {
  private readonly users = new Map<string, CreateUserDto>();

  create(createUserDto: CreateUserDto) {
    this.users.set(createUserDto.id, createUserDto);
    return createUserDto;
  }

  findOne(id: string): CreateUserDto | undefined {
    return this.users.get(id);
  }
}

export class CreateUserDto {
  id: string;
  firstName: string;
  lastName: string;
  age: number;
}
```

#### C16.5 - Appliquer les bonnes pratiques d’écoconception afin de minimiser l’impact écologique de la partie back-end de l’application
J'ai intégré des pratiques d'écoconception pour minimiser l'impact écologique de la partie back-end des applications. Cela inclut l'optimisation des requêtes pour réduire la consommation de ressources, l'utilisation d'algorithmes efficaces pour limiter les cycles de calcul, et l'adoption de pratiques de programmation frugales. De plus, j'ai utilisé des services cloud avec une infrastructure éco-responsable et des configurations permettant de réduire la consommation énergétique des serveurs.

```typescript
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { MongoClient } from 'mongodb';

@Injectable()
export class AppService implements OnModuleInit, OnModuleDestroy {
  private client: MongoClient;

  async onModuleInit() {
    this.client = new MongoClient(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    await this.client.connect();
    console.log('Connected to MongoDB');
  }

  async onModuleDestroy() {
    await this.client.close();
    console.log('Disconnected from MongoDB');
  }

  async getData() {
    const db = this.client.db('mydatabase');
    const collection = db.collection('mycollection');
    return collection.find({}).toArray();
  }
}
```

